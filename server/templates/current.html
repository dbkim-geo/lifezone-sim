<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>현재 생활권 살펴보기</title>
    <link rel="icon" href="/static/images/favicon.png" type="image/png">
    <!-- Tailwind CSS (Aesthetics and Responsiveness) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- OpenLayers CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.15.1/css/ol.css" type="text/css">
    <!-- OpenLayers JS -->
    <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.15.1/build/ol.js"></script>
    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- Chart.js (for Radar Chart) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Global font setting for consistency */
        body { font-family: 'Inter', sans-serif; }
        
        /* Main Content and Map Container Styling for Full Height */
        .full-height-flex { 
            height: calc(100vh - 56px); /* Full viewport height minus header height */
        }
        #map-container {
            width: 100%;
            height: 100%; /* Important: This MUST take up 100% of its parent's height (which is flex-grow) */
        }
        .map-wrapper {
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            height: 100%; /* Important for grid cells to distribute height */
        }
        .map {
            width: 100%;
            flex-grow: 1; /* Map div takes remaining space in wrapper */
        }
        /* Custom scrollbar for control panel */
        #control-panel::-webkit-scrollbar {
            width: 6px;
        }
        #control-panel::-webkit-scrollbar-thumb {
            background: #9ca3af;
            border-radius: 10px;
        }
        /* Chart container styling to limit its size */
        #radarChartContainer {
            height: auto;
            max-height: 350px; /* Limit chart height */
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen flex flex-col font-sans">

    <!-- Header -->
    <header class="bg-white shadow-md p-4 flex justify-between items-center z-10">
        <h1 class="text-xl font-bold text-gray-800">생활권 특성 분석 WebGIS</h1>
        <div class="text-sm text-gray-500">KRIHS 인터랙티브 분석 리포트 (샘플)</div>
    </header>

    <!-- Main Content Area: Use custom class for height calculation -->
    <main class="full-height-flex flex flex-col lg:flex-row p-4 space-y-4 lg:space-y-0 lg:space-x-4">
        
        <!-- Left Control Panel (Sidebar) -->
        <aside id="control-panel" class="bg-white p-5 rounded-xl shadow-lg lg:w-80 w-full flex-shrink-0 h-auto lg:h-full overflow-y-auto">
            <h2 class="text-lg font-semibold mb-4 text-indigo-700 border-b pb-2">분석 옵션 선택</h2>

            <!-- 1. 생활권 구분 토글 -->
            <div class="mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-2">생활권 수준</label>
                <div class="flex bg-gray-100 rounded-full p-1" id="living-area-toggle">
                    <button data-level="basic" class="flex-1 py-2 text-sm font-medium rounded-full transition-colors duration-200 bg-indigo-600 text-white shadow-md">
                        기초생활권
                    </button>
                    <button data-level="regional" class="flex-1 py-2 text-sm font-medium rounded-full text-gray-700 hover:bg-gray-200 transition-colors duration-200">
                        지역생활권
                    </button>
                </div>
            </div>

            <!-- 2. 지표 선택 (Dynamic Checkboxes - 2 Column Grid) -->
            <div class="mb-6 border-t pt-4">
                <label class="block text-sm font-medium text-gray-700 mb-3">시각화 지표 선택 (최대 4개)</label>
                <div id="indicator-selection" class="">
                    <!-- Dynamic Checkboxes will be inserted here -->
                </div>
            </div>

            <!-- 3. 시각화 버튼 -->
            <button id="visualize-button" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 shadow-md transform hover:scale-105">
                시각화하기
            </button>

            <!-- 4. 지도 분할 옵션 -->
            <div class="mt-6 pt-4 border-t">
                <label class="block text-sm font-medium text-gray-700 mb-2">지도 분할 옵션</label>
                <select id="map-split-select" class="w-full p-2 border border-gray-300 rounded-lg text-sm bg-white focus:ring-indigo-500 focus:border-indigo-500">
                    <option value="1">지도 1개</option>
                    <option value="2">지도 2개 (좌우 분할)</option>
                    <option value="4">지도 4개 (2x2 분할)</option>
                </select>
            </div>
        </aside>

        <!-- Right Map and Stats Area -->
        <!-- Use h-full here to ensure this column takes the full available height of <main> -->
        <div class="flex-grow flex flex-col space-y-4 h-full"> 
            
            <!-- Stats Area (Radar Chart) - Limited Max Height -->
            <section class="bg-white rounded-xl shadow-lg p-5 flex-shrink-0" id="radarChartContainer">
                <h2 class="text-lg font-semibold mb-2 text-indigo-700">한 눈에 보는 생활권 특성 (총 34/21종 지표 분석)</h2>
                <!-- Adjusted height for better chart visibility -->
                <div class="flex justify-center items-center h-full max-h-[300px]"> 
                    <canvas id="radarChart"></canvas>
                </div>
            </section>

            <!-- Map Area - Takes remaining height, flex-grow -->
            <section class="bg-white rounded-xl shadow-lg flex-grow overflow-hidden p-2">
                <h2 class="text-base font-semibold text-gray-600 mb-2 px-2">생활권 시각화 지도</h2>
                <!-- Map Container: Dynamic grid for 1, 2, or 4 maps. h-full is critical here. -->
                <div id="map-container" class="grid grid-cols-1 gap-1"> 
                    <div id="map-1-wrapper" class="map-wrapper"><div id="map-1" class="map"></div></div>
                </div>
            </section>
        </div>
    </main>

    <!-- Jinja2 Escape Block BEGIN -->
    {% raw %}
    <script>
        // Global variables for OpenLayers and state management
        let activeMaps = []; // Array to hold all active ol.Map instances
        let vectorSource; // Reusable source for all vector layers
        let currentLevel = 'basic'; // 'basic' for 기초생활권, 'regional' for 지역생활권
        let radarChart;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'; // Firestore placeholder
        
        // --- MOCK DATA STRUCTURES ---
        // Helper to generate numbered indicators
        const genIndicators = (baseName, count, start = 1) => 
            Array.from({ length: count }, (_, i) => `${baseName}${start + i}`);

        const MOCK_DATA = {
            basic: {
                levelName: "기초생활권",
                categories: {
                    // 기본현황 20종
                    "기본현황": [
                        ...genIndicators("기본현황", 2, 1).map(name => `${name} (인구/고령화)`),
                        ...genIndicators("기본현황", 18, 3).map(name => `${name} (현황)`),
                    ],
                    // 콤팩트성 4종
                    "콤팩트성": genIndicators("콤팩트성", 4).map(name => `${name} (집약도)`),
                    // 네트워크성 6종
                    "네트워크성": genIndicators("네트워크성", 6).map(name => `${name} (접근성)`),
                    // 생활편리성 4종
                    "생활편리성": genIndicators("생활편리성", 4).map(name => `${name} (편의성)`),
                },
                indicatorSchema: { // For Radar Chart labels (Overall categories, used for collecting ALL indicators)
                    "기본현황": 20, "콤팩트성": 4, "네트워크성": 6, "생활편리성": 4
                }
            },
            regional: {
                levelName: "지역생활권",
                categories: {
                    // 기본현황 6종
                    "기본현황": genIndicators("기본현황", 6).map(name => `${name} (총량)`),
                    // 콤팩트성 4종
                    "콤팩트성": genIndicators("콤팩트성", 4).map(name => `${name} (균형)`),
                    // 네트워크성 6종
                    "네트워크성": genIndicators("네트워크성", 6).map(name => `${name} (광역연계)`),
                    // 생활편리성 5종
                    "생활편리성": genIndicators("생활편리성", 5).map(name => `${name} (기관접근)`),
                },
                indicatorSchema: { // For Radar Chart labels (Overall categories, used for collecting ALL indicators)
                    "기본현황": 6, "콤팩트성": 4, "네트워크성": 6, "생활편리성": 5
                }
            }
        };
        
        // Function to flatten all indicators for the current level
        function getAllIndicators() {
            const data = MOCK_DATA[currentLevel];
            let allIndicators = [];
            for (const category in data.categories) {
                allIndicators = allIndicators.concat(data.categories[category]);
            }
            return allIndicators;
        }


        // Mock GeoJSON data (simple square features for demonstration)
        const mockGeoJson = {
            'type': 'FeatureCollection',
            'crs': { 'type': 'name', 'properties': { 'name': 'EPSG:3857' } },
            'features': [
                // Mock features must contain property names matching the expanded MOCK_DATA keys for "기본현황1 (인구/고령화)" etc.
                // NOTE: Only a few properties are mocked here for brevity; the rest are randomly generated on click.
                { 'type': 'Feature', 'geometry': { 'type': 'Polygon', 'coordinates': [[[13945000, 4500000], [14000000, 4500000], [14000000, 4550000], [13945000, 4550000], [13945000, 4500000]]] }, 'properties': { 'fid': 1, '지역명': '강남권역', '기본현황1 (인구/고령화)': 85, '콤팩트성1 (집약도)': 70, '네트워크성1 (접근성)': 90, '생활편리성1 (편의성)': 60 } },
                { 'type': 'Feature', 'geometry': { 'type': 'Polygon', 'coordinates': [[[13890000, 4500000], [13945000, 4500000], [13945000, 4550000], [13890000, 4550000], [13890000, 4500000]]] }, 'properties': { 'fid': 2, '지역명': '강북권역', '기본현황1 (인구/고령화)': 40, '콤팩트성1 (집약도)': 55, '네트워크성1 (접근성)': 60, '생활편리성1 (편의성)': 75 } },
                { 'type': 'Feature', 'geometry': { 'type': 'Polygon', 'coordinates': [[[13945000, 4550000], [14000000, 4550000], [14000000, 4600000], [13945000, 4600000], [13945000, 4550000]]] }, 'properties': { 'fid': 3, '지역명': '영남권역', '기본현황1 (인구/고령화)': 65, '콤팩트성1 (집약도)': 80, '네트워크성1 (접근성)': 75, '생활편리성1 (편의성)': 50 } },
                { 'type': 'Feature', 'geometry': { 'type': 'Polygon', 'coordinates': [[[13890000, 4550000], [13945000, 4550000], [13945000, 4600000], [13890000, 4600000], [13890000, 4550000]]] }, 'properties': { 'fid': 4, '지역명': '호남권역', '기본현황1 (인구/고령화)': 30, '콤팩트성1 (집약도)': 45, '네트워크성1 (접근성)': 50, '생활편리성1 (편의성)': 85 } }
            ]
        };

        // --- OPENLAYERS FUNCTIONS ---

        /**
         * Initialize the common vector source on first load.
         */
        function initVectorSource() {
            if (!vectorSource) {
                 vectorSource = new ol.source.Vector({
                    features: (new ol.format.GeoJSON()).readFeatures(mockGeoJson, {
                        featureProjection: 'EPSG:3857'
                    })
                });
            }
        }

        /**
         * Generates a random color for a feature based on a mock value (0-100).
         * @param {number} value Indicator value (0-100)
         * @returns {string} Hex color string
         */
        function getColor(value) {
            // Simple color gradient: Blue (Low) -> Yellow (Mid) -> Red (High)
            const normalized = Math.min(100, Math.max(0, value)) / 100;
            let r, g, b;

            if (normalized < 0.5) {
                // Blue to Yellow transition (0.0 to 0.5)
                r = Math.round(255 * 2 * normalized);
                g = Math.round(255 * 2 * normalized);
                b = Math.round(255 - 255 * 2 * normalized);
            } else {
                // Yellow to Red transition (0.5 to 1.0)
                r = 255;
                g = Math.round(255 * (1 - 2 * (normalized - 0.5)));
                b = 0;
            }

            return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        /**
         * Default style for features (No selection yet).
         * @returns {ol.style.Style}
         */
        function defaultStyleFunction() {
            return new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: 'rgba(50, 50, 50, 0.5)',
                    width: 1
                }),
                fill: new ol.style.Fill({
                    color: 'rgba(200, 200, 200, 0.3)'
                })
            });
        }

        /**
         * Dynamic style function based on a specific indicator.
         * @param {string} indicatorKey The property name (indicator) to visualize.
         * @returns {ol.style.StyleFunction}
         */
        function createIndicatorStyleFunction(indicatorKey) {
            return function(feature) {
                // Find the property key that starts with the indicator's main category/name
                let keyToUse = indicatorKey;
                if (!feature.get(indicatorKey)) {
                    // Fallback logic to find the closest matching key in mock data
                    keyToUse = Object.keys(feature.getProperties()).find(k => k.startsWith(indicatorKey.split(' ')[0])) || indicatorKey;
                }
                
                const value = feature.get(keyToUse) || Math.floor(Math.random() * 100);
                const color = getColor(value);

                return new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: 'rgba(0, 0, 0, 0.7)',
                        width: 1.5
                    }),
                    fill: new ol.style.Fill({
                        color: color + 'CC' // Add transparency (CC = ~80%)
                    }),
                    text: new ol.style.Text({
                        text: feature.get('지역명'),
                        font: '14px Noto Sans',
                        fill: new ol.style.Fill({ color: '#000' }),
                        stroke: new ol.style.Stroke({ color: '#fff', width: 3 })
                    })
                });
            };
        }
        
        /**
         * Create and initialize a single OpenLayers map.
         * @param {string} targetId The ID of the div element to render the map into.
         * @param {string} indicatorKey The indicator to visualize on this map.
         * @param {ol.View | null} masterView The view to link to for synchronization. If null, a new view is created.
         * @returns {ol.Map} The created map instance.
         */
        function createSingleMap(targetId, indicatorKey, masterView = null) {
            // 1. Create Vector Layer
            const vectorLayer = new ol.layer.Vector({
                source: vectorSource,
                style: createIndicatorStyleFunction(indicatorKey), 
                zIndex: 1
            });

            // 2. Determine View: Use masterView if provided, otherwise create a new one.
            const view = masterView || new ol.View({
                center: ol.proj.fromLonLat([127.5, 36.5]),
                zoom: 7
            });

            // 3. Create Map Instance
            const newMap = new ol.Map({
                target: targetId,
                layers: [
                    new ol.layer.Tile({ source: new ol.source.OSM(), zIndex: 0 }), // Base Layer
                    vectorLayer
                ],
                view: view // Use the shared view or the newly created one
            });
            
            // 4. Attach click handler for feature info
            newMap.on('singleclick', handleMapClick);

            // 5. Fit view to data extent (ONLY if it's the master view/newly created view)
            if (!masterView) {
                newMap.getView().fit(vectorSource.getExtent(), { padding: [20, 20, 20, 20], duration: 500 });
            }

            return newMap;
        }


        /**
         * Handles feature click event and updates Radar Chart.
         * @param {ol.MapBrowserEvent} event
         */
        function handleMapClick(event) {
            const mapInstance = event.map;
            const hit = mapInstance.forEachFeatureAtPixel(event.pixel, (feature, layer) => {
                return feature; // Return the first feature found
            });

            if (hit) {
                const regionName = hit.get('지역명');
                const props = hit.getProperties();
                
                console.log('Feature Clicked:', regionName, props);
                // Update Radar Chart with selected feature data
                updateRadarChartWithFeature(regionName, props);
            } else {
                console.log('No feature clicked.');
                resetRadarChart();
            }
        }

        // --- UI & STATE MANAGEMENT FUNCTIONS (jQuery) ---

        /**
         * Updates the list of selectable indicators based on the living area level.
         */
        function updateIndicatorsUI() {
            const data = MOCK_DATA[currentLevel];
            const $container = $('#indicator-selection');
            $container.empty();

            for (const category in data.categories) {
                const indicators = data.categories[category];
                
                // Start of a new category block with aesthetic improvements
                let categoryHtml = `
                    <div class="category-block mb-6 last:mb-0 p-3 border border-gray-200 rounded-xl shadow-inner bg-gray-50">
                        <p class="text-sm font-bold text-indigo-800 mb-3 border-b border-indigo-200 pb-1">${category} (${indicators.length}종)</p>
                        <!-- Responsive Grid for indicators: 2 columns on all screens -->
                        <div class="grid grid-cols-2 gap-x-3 gap-y-2">
                `;
                
                indicators.forEach(indicator => {
                    // Replace special characters in indicator name for valid HTML ID
                    const id = `chk-${indicator.replace(/[\s\(\)\/]/g, '_')}`;
                    categoryHtml += `
                        <div class="flex items-center">
                            <input id="${id}" type="checkbox" name="indicator" value="${indicator}" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 cursor-pointer">
                            <!-- Use text-xs for smaller font and title for full name, truncate long names -->
                            <label for="${id}" class="ml-2 block text-xs text-gray-800 cursor-pointer truncate" title="${indicator}">${indicator}</label>
                        </div>
                    `;
                });
                
                categoryHtml += `</div></div>`;
                $container.append(categoryHtml);
            }

            // Limit checkbox selection to 4
            $('input[name="indicator"]').on('change', function() {
                const checkedCount = $('input[name="indicator"]:checked').length;
                if (checkedCount > 4) {
                    this.checked = false;
                    displayMessage('경고', '최대 4개의 지표만 선택 가능합니다.');
                }
            });
        }

        /**
         * Displays a custom message box instead of alert.
         * @param {string} title
         * @param {string} message
         */
        function displayMessage(title, message) {
            // Create a simple modal/message box dynamically
            const $modal = $(`
                <div id="custom-alert" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50 transition-opacity duration-300 opacity-0">
                    <div class="bg-white p-6 rounded-lg shadow-2xl w-80 transform scale-95 transition-transform duration-300">
                        <h3 class="text-lg font-bold ${title === '경고' ? 'text-red-600' : 'text-blue-600'} mb-3">${title}</h3>
                        <p class="text-sm text-gray-700 mb-4">${message}</p>
                        <button class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-medium py-2 rounded-lg" onclick="$('#custom-alert').remove()">확인</button>
                    </div>
                </div>
            `);
            $('body').append($modal);
            setTimeout(() => $modal.css('opacity', 1).find('> div').css('transform', 'scale(100%)'), 10);
        }

        /**
         * Toggles the living area level (기초/지역).
         */
        $('#living-area-toggle').on('click', 'button', function() {
            const selectedLevel = $(this).data('level');
            if (currentLevel === selectedLevel) return;

            // Update UI state
            $('#living-area-toggle button').removeClass('bg-indigo-600 text-white shadow-md hover:bg-gray-200 text-gray-700')
                                          .addClass('text-gray-700 hover:bg-gray-200');
            $(this).removeClass('text-gray-700 hover:bg-gray-200')
                   .addClass('bg-indigo-600 text-white shadow-md');

            currentLevel = selectedLevel;
            updateIndicatorsUI();
            
            // Re-render map/chart for new default state
            visualizeMap(); // Will reset map to a single view if needed
            initRadarChart(); // Re-initialize radar chart with new overall data
        });


        /**
         * '시각화하기' button handler. Implements map splitting and ensures correct grid layout.
         */
        $('#visualize-button').on('click', visualizeMap);

        function visualizeMap() {
            // Destroy all existing maps before starting
            activeMaps.forEach(map => map.setTarget(null));
            activeMaps = [];

            const allSelectedIndicators = $('input[name="indicator"]:checked').map(function() {
                return $(this).val();
            }).get();
            
            const splitMode = parseInt($('#map-split-select').val());
            
            // Determine how many maps to actually display: min(selected_indicators, split_mode)
            const numMapsToShow = Math.min(allSelectedIndicators.length > 0 ? allSelectedIndicators.length : 1, splitMode);
            
            const indicatorsToDisplay = allSelectedIndicators.slice(0, numMapsToShow);

            if (indicatorsToDisplay.length === 0) {
                 // Fallback to a single, default grey map (if 0 selected)
                indicatorsToDisplay.push('기본현황1 (인구/고령화)'); // Use a default key for the single grey map
            }

            console.log(`Displaying ${numMapsToShow} map(s) with indicators:`, indicatorsToDisplay);

            const $mapContainer = $('#map-container');
            $mapContainer.empty();

            // === 1. 지도 컨테이너 레이아웃 설정 ===
            let gridLayout = '';
            // Tailwind CSS classes for grid layout
            if (numMapsToShow === 1) {
                gridLayout = 'grid-cols-1 grid-rows-1';
            } else if (numMapsToShow === 2) {
                gridLayout = 'grid-cols-2 grid-rows-1'; // 좌우 분할
            } else if (numMapsToShow >= 3) { 
                gridLayout = 'grid-cols-2 grid-rows-2'; // 2x2 분할 강제 (3개든 4개든 2x2가 가장 안정적)
            }
            // Add h-full back to ensure it takes available height
            $mapContainer.attr('class', `h-full grid gap-1 ${gridLayout}`); 
            
            // === 2. 지도 생성 및 시각화 ===
            let masterView = null; // 마스터 뷰를 저장할 변수
            
            for (let i = 0; i < numMapsToShow; i++) {
                const mapId = `map-${i + 1}`;
                const indicatorKey = indicatorsToDisplay[i];

                // Create wrapper and map div
                const mapHtml = `
                    <div id="${mapId}-wrapper" class="map-wrapper">
                        <div class="text-sm font-semibold text-gray-700 p-2 bg-indigo-50 border-b border-indigo-200 truncate" title="${indicatorKey}">
                            지도 ${i + 1}: ${indicatorKey}
                        </div>
                        <div id="${mapId}" class="map flex-grow"></div>
                    </div>
                `;
                $mapContainer.append(mapHtml);
                
                // Initialize OpenLayers Map
                const key = (allSelectedIndicators.length === 0 && i === 0) ? 'DEFAULT_GREY' : indicatorKey;
                
                let newMap;
                if (i === 0) {
                    // 첫 번째 지도(마스터)를 생성하고 뷰를 저장합니다.
                    newMap = createSingleMap(mapId, key, null); // masterView = null, so it creates a new ol.View
                    masterView = newMap.getView();
                } else {
                    // 나머지 지도는 마스터 뷰를 공유하도록 생성합니다.
                    newMap = createSingleMap(mapId, key, masterView);
                }

                activeMaps.push(newMap);

                // For the default state (0 selected), manually apply the grey style
                if (allSelectedIndicators.length === 0 && i === 0) {
                    newMap.getLayers().getArray().find(layer => layer instanceof ol.layer.Vector).setStyle(defaultStyleFunction);
                }
                
                // Manually trigger map resize/render after DOM manipulation
                // This is crucial for OpenLayers in dynamic layouts
                setTimeout(() => {
                    newMap.updateSize();
                }, 50);
            }
            
            // Display message based on the outcome
            if (allSelectedIndicators.length === 0) {
                 displayMessage('알림', '선택된 지표가 없어 기본 현황(1개 지도)으로 초기화했습니다.');
            } else {
                 displayMessage('성공', `${numMapsToShow}개의 지표를 ${numMapsToShow}개 지도로 분할하여 시각화했습니다. 지도 뷰가 동기화되었습니다.`);
            }
        }

        // --- CHART.JS FUNCTIONS ---

        /**
         * Generates mock data for the radar chart (Individual Indicator Characteristics).
         * @returns {Object} object containing labels and data arrays
         */
        function generateIndividualMockData() {
            const labels = getAllIndicators();
            const totalCount = labels.length;
            
            // Generate random normalized values (e.g., score 0-100)
            const scores = labels.map(() => Math.floor(Math.random() * 50) + 50); // 50 to 100 range for 'Overall'
            
            return { labels: labels, data: scores, totalCount: totalCount };
        }

        /**
         * Initialize or reset the Radar Chart to show the overall average based on ALL indicators.
         */
        function initRadarChart() {
            if (radarChart) {
                radarChart.destroy();
            }

            const ctx = document.getElementById('radarChart').getContext('2d');
            const mockData = generateIndividualMockData();

            // Update section title to reflect the total number of indicators
            const totalIndicators = MOCK_DATA[currentLevel].indicatorSchema;
            const totalCount = Object.values(totalIndicators).reduce((a, b) => a + b, 0);
            $('#radarChartContainer h2').text(`한 눈에 보는 생활권 특성 (총 ${totalCount}종 지표 분석)`);

            radarChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: mockData.labels, // ALL 34 or 21 indicators become the labels
                    datasets: [{
                        label: `${MOCK_DATA[currentLevel].levelName} 전체 평균 특성`,
                        data: mockData.data,
                        backgroundColor: 'rgba(59, 130, 246, 0.2)', // Indigo 500 w/ opacity
                        borderColor: 'rgb(59, 130, 246)',
                        pointRadius: 1, // Reduce point size due to high number of points
                        pointHitRadius: 5,
                        pointBackgroundColor: 'rgb(59, 130, 246)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgb(59, 130, 246)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            angleLines: { display: true, color: 'rgba(0, 0, 0, 0.1)' },
                            suggestedMin: 0,
                            suggestedMax: 100,
                            pointLabels: { 
                                font: { size: 6 }, // Very small font size for 34 labels
                                padding: 5,
                                callback: function(label) {
                                    // Shorten labels dramatically to prevent overlap (e.g., show only Indicator Name)
                                    return label.split(' ')[0];
                                }
                            },
                            ticks: { display: false }
                        }
                    },
                    plugins: {
                        legend: { position: 'top' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    // Show full label in tooltip
                                    return context.dataset.label + ' (' + context.label + '): ' + context.parsed.r + '점';
                                }
                            }
                        }
                    }
                }
            });
        }

        /**
         * Update Radar Chart with the selected feature's data.
         * @param {string} regionName
         * @param {Object} props Feature properties
         */
        function updateRadarChartWithFeature(regionName, props) {
            const allIndicators = getAllIndicators();
            
            // Generate mock scores for the selected feature for ALL 34/21 indicators
            const featureScores = allIndicators.map(indicatorKey => {
                // In a real app, you would look up props[indicatorKey]
                // Here, we generate a random score (0-100) as mock data
                return Math.floor(Math.random() * 100); 
            });

            // Check if the feature dataset already exists and remove it
            if (radarChart.data.datasets.length > 1) {
                radarChart.data.datasets.pop();
            }

            // Add the new feature dataset
            radarChart.data.datasets.push({
                label: `${regionName} 특성 (클릭 영역)`,
                data: featureScores,
                backgroundColor: 'rgba(239, 68, 68, 0.2)', // Red 500 w/ opacity
                borderColor: 'rgb(239, 68, 68)',
                pointRadius: 1,
                pointHitRadius: 5,
                pointBackgroundColor: 'rgb(239, 68, 68)',
                pointBorderColor: '#fff',
                pointHoverBackgroundColor: '#fff',
                pointHoverBorderColor: 'rgb(239, 68, 68)'
            });

            radarChart.update();
        }

        /**
         * Reset Radar Chart to show only the overall average.
         */
        function resetRadarChart() {
             if (radarChart.data.datasets.length > 1) {
                radarChart.data.datasets.pop();
                radarChart.update();
            }
        }

        // --- INITIALIZATION ---
        $(document).ready(function() {
            // 1. Initialize Vector Source
            initVectorSource();

            // 2. Initialize Control Panel UI (Default: Basic)
            updateIndicatorsUI();

            // 3. Initialize Radar Chart (MUST run first to show overall data)
            initRadarChart();

            // 4. Set initial map visualization (Default: Basic/기본현황 중 1개 표시)
            // Select the first indicator and visualize it as a single map
            const firstIndicator = MOCK_DATA.basic.categories["기본현황"][0];
            // Replace special characters in indicator name for valid HTML ID
            const safeId = `#chk-${firstIndicator.replace(/[\s\(\)\/]/g, '_')}`;

            setTimeout(() => {
                // Check the default indicator and run visualization
                $(safeId).prop('checked', true); 
                visualizeMap();
            }, 500); 
        });
    </script>
    {% endraw %}
    <!-- Jinja2 Escape Block END -->

</body>
</html>